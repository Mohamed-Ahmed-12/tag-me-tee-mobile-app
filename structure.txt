import React, { createContext, useCallback, useEffect, useState, useRef } from 'react';
import { Alert } from 'react-native';
import { API_BASE_URL } from '@env';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { jwtDecode } from "jwt-decode"

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
    const router = useRouter();
    const [tokens, setTokens] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [isProfileLoading, setIsProfileLoading] = useState(false);
    const [isUpdating, setIsUpdating] = useState(false);
    const [profileData, setProfileData] = useState(null);
    const [errors, setErrors] = useState(null);
    const isMountedRef = useRef(true);

    // Check if token is expired
    const isTokenExpired = useCallback((token) => {
        if (!token) return true;
        try {
            // Check if it's a valid JWT structure first
            if (token.split('.').length !== 3) return true;

            const decoded = jwtDecode(token);
            console.log(decoded)
            // Add buffer (e.g., 5 minutes) to prevent edge cases
            return (decoded.exp * 1000) < (Date.now() + 300000);
        } catch (error) {
            console.error("Error decoding token:", error);
            return true;
        }
    }, []);

    const clearErrors = useCallback(() => {
        setErrors(null);
    }, []);

    // Clear all auth-related data
    const clearAuthData = useCallback(async () => {
        try {
            await AsyncStorage.removeItem('tokens');
            if (isMountedRef.current) {
                setTokens(null);
                setProfileData(null);
                setErrors(null);
            }
        } catch (error) {
            console.error("Failed to clear auth data:", error);
            throw error;
        }
    }, []);

    // Handle expired token
    const handleExpiredToken = useCallback(async () => {
        await clearAuthData();
        Alert.alert("Session Expired", "Your session has expired. Please login again.");
        router.replace('/login');
    }, [clearAuthData, router]);

    // Enhanced request function with token checks
    const makeAuthenticatedRequest = useCallback(async (url, options = {}) => {
        // Check token expiration before making request
        if (!tokens?.access || isTokenExpired(tokens.access)) {
            // Attempt to refresh token if we have a refresh token
            if (tokens?.refresh && !isTokenExpired(tokens.refresh)) {
                const refreshSuccess = await refreshTokens();
                if (!refreshSuccess) {
                    await handleExpiredToken();
                    return null;
                }
                // Retry with new tokens
                return makeAuthenticatedRequest(url, options);
            }
            await handleExpiredToken();
            return null;
        }

        const defaultHeaders = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${tokens.access}`
        };

        try {
            const response = await fetch(url, {
                ...options,
                headers: {
                    ...defaultHeaders,
                    ...options.headers
                }
            });

            if (response.status === 401) {
                // Token might be expired but not detected initially
                await handleExpiredToken();
                return null;
            }

            return response;
        } catch (error) {
            console.error("Request failed:", error);
            throw error;
        }
    }, [tokens, isTokenExpired, handleExpiredToken, refreshTokens]);

    const logout = useCallback(async () => {
        setIsLoading(true);
        try {
            await clearAuthData();
            router.replace('/login');
        } catch (error) {
            console.error("Logout failed:", error);
            Alert.alert("Error", "An error occurred while logging out. Please try again.");
        } finally {
            if (isMountedRef.current) {
                setIsLoading(false);
            }
        }
    }, [clearAuthData, router]);

    const login = useCallback(async (inputData) => {
        setIsLoading(true);
        setErrors(null);

        try {
            const url = `${API_BASE_URL}/login/`;
            const response = await fetch(url, {
                method: "POST",
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(inputData),
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error("Login failed:", response.status, errorData);
                if (isMountedRef.current) {
                    setErrors(errorData?.detail || "Invalid credentials");
                }
                Alert.alert("Login Failed", errorData.message || "Please check your credentials.");
                return false;
            }

            const data = await response.json();

            // Store tokens first
            await AsyncStorage.setItem('tokens', JSON.stringify(data));

            if (isMountedRef.current) {
                // Set tokens in state
                setTokens(data);

                // Fetch profile without immediate expiration check
                try {
                    await userProfile();
                } catch (profileError) {
                    console.error("Profile fetch failed:", profileError);
                    // Don't treat this as a fatal error
                }

                router.replace('/profile');
            }
            return true;
        } catch (error) {
            console.error("Network error or request failed:", error);
            if (isMountedRef.current) {
                setErrors("Network error");
            }
            Alert.alert("Error", "Could not connect to the server. Please check your internet connection.");
            return false;
        } finally {
            if (isMountedRef.current) {
                setIsLoading(false);
            }
        }
    }, [userProfile, router]);

    const userProfile = useCallback(async () => {
        // Skip immediate token check for fresh logins
        if (!tokens?.access) return false;

        setIsProfileLoading(true);
        setErrors(null);

        try {
            const url = `${API_BASE_URL}/users/me/`;
            const response = await fetch(url, {
                method: "GET",
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${tokens.access}`
                },
            });

            if (!response.ok) {
                const errorData = await response.json();
                if (response.status === 401) {
                    await handleExpiredToken();
                    return false;
                }
                throw new Error(errorData.message || "Failed to fetch profile");
            }

            const data = await response.json();
            if (isMountedRef.current) {
                setProfileData(data);
            }
            return true;
        } catch (error) {
            console.error("Fetch profile failed:", error);
            if (isMountedRef.current) {
                setErrors(error.message);
            }
            // Don't show alert here to prevent double alerts
            return false;
        } finally {
            if (isMountedRef.current) {
                setIsProfileLoading(false);
            }
        }
    }, [tokens, handleExpiredToken]);

    const updateUserProfile = useCallback(async (updatedFields, uid) => {
        setIsUpdating(true);
        setErrors(null);

        try {
            const url = `${API_BASE_URL}/users/${uid}/`;
            const response = await makeAuthenticatedRequest(url, {
                method: 'PUT',
                body: JSON.stringify(updatedFields)
            });

            if (!response) return false; // Token was expired and handled

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || "Failed to update profile");
            }

            const updatedData = await response.json();
            if (isMountedRef.current) {
                setProfileData(updatedData);
            }
            Alert.alert("Success", "Profile updated successfully!");
            return true;
        } catch (error) {
            console.error("Update profile failed:", error);
            if (isMountedRef.current) {
                setErrors(error.message);
            }
            Alert.alert("Error", `Failed to update profile: ${error.message}`);
            return false;
        } finally {
            if (isMountedRef.current) {
                setIsUpdating(false);
            }
        }
    }, [makeAuthenticatedRequest]);

    const refreshTokens = useCallback(async () => {
        if (!tokens?.refresh || isTokenExpired(tokens.refresh)) {
            await handleExpiredToken();
            return false;
        }

        try {
            const url = `${API_BASE_URL}/token/refresh/`;
            const response = await fetch(url, {
                method: "POST",
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ refresh: tokens.refresh }),
            });

            if (!response.ok) {
                throw new Error("Failed to refresh tokens");
            }

            const newTokens = await response.json();
            await AsyncStorage.setItem('tokens', JSON.stringify(newTokens));
            if (isMountedRef.current) {
                setTokens(newTokens);
            }
            return true;
        } catch (error) {
            console.error("Token refresh failed:", error);
            await handleExpiredToken();
            return false;
        }
    }, [tokens, isTokenExpired, handleExpiredToken]);

    // Initialize auth state from storage
    useEffect(() => {
        isMountedRef.current = true;

        const loadUserFromStorage = async () => {
            if (!isMountedRef.current) return;

            setIsLoading(true);
            try {
                const storedTokens = await AsyncStorage.getItem('tokens');

                if (!isMountedRef.current) return;

                if (storedTokens) {
                    const parsedTokens = JSON.parse(storedTokens);

                    // Check token expiration immediately
                    if (isTokenExpired(parsedTokens?.access)) {
                        // Try to refresh if refresh token is valid
                        if (parsedTokens?.refresh && !isTokenExpired(parsedTokens.refresh)) {
                            const newTokens = await refreshTokens();
                            if (!newTokens) return;
                        } else {
                            await handleExpiredToken();
                            return;
                        }
                    }

                    if (isMountedRef.current) {
                        setTokens(parsedTokens);
                        await userProfile();
                    }
                } else {
                    await clearAuthData();
                    if (isMountedRef.current) router.replace('/login');
                }
            } catch (error) {
                console.error("Failed to load tokens from storage", error);
                if (isMountedRef.current) {
                    await clearAuthData();
                }
            } finally {
                if (isMountedRef.current) {
                    setIsLoading(false);
                }
            }
        };

        loadUserFromStorage();

        return () => {
            isMountedRef.current = false;
        };
    }, [userProfile, isTokenExpired, handleExpiredToken, refreshTokens, clearAuthData, router]);

    return (
        <AuthContext.Provider
            value={{
                tokens,
                profileData,
                errors,
                isLoading,
                isProfileLoading,
                isUpdating,
                login,
                logout,
                userProfile,
                updateUserProfile,
                refreshTokens,
                clearAuthData,
                clearErrors,
            }}
        >
            {children}
        </AuthContext.Provider>
    );
};